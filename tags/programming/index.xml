<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>programming on Guy Bianco IV</title><link>https://guy.sh/tags/programming/</link><description>Recent content in programming on Guy Bianco IV</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 29 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://guy.sh/tags/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Tool Complexity</title><link>https://guy.sh/posts/tool-complexity/</link><pubDate>Fri, 29 Jan 2021 00:00:00 +0000</pubDate><guid>https://guy.sh/posts/tool-complexity/</guid><description>Recently, I had a conversation with a few colleagues about the complexity of software tooling. It came up after a humorous post that complained about a particular tool (I won&amp;rsquo;t say which) being overly complex. Not just complex, but the author claimed it was maliciously and intentionally designed to be complex as a form of gatekeeping.
It seemed as though this person ran into the same pitfall as a lot of developers: being expected to quickly learn an unexpectedly complex tool.</description></item><item><title>Web Component Navigation</title><link>https://guy.sh/posts/wc-navigation/</link><pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate><guid>https://guy.sh/posts/wc-navigation/</guid><description>On my last consulting project, we used Web Components to stitch large pieces of the UI together.
Kinda like non-awful inverse iframes.
Each application provided its own UI, which would include/import a big navigation web component that had its own lifecycle. The boundary was kept relatively clean since a web component can only communicate with its parent via element attributes.
Basically, we designed it where the parent controlled the state of the navigation by putting a couple of JSON blobs on specific attributes.</description></item></channel></rss>